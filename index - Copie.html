<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Blob visqueux avec bulles montantes</title>
<style>
  :root {
    --bg-dark: #120a1f;
    --text-light: #f0f0f0;
  }
  * {
    margin: 0; padding: 0; box-sizing: border-box;
  }
  html, body {
    height: 100%;
    background: var(--bg-dark);
    color: var(--text-light);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    overflow: hidden;
  }
  canvas {
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    z-index: 0;
    pointer-events: none;
    display: block;
  }
  .container {
    position: relative;
    z-index: 10;
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 2rem;
  }
  .card {
    width: 100%;
    max-width: 480px;
    padding: 2rem;
    border-radius: 1.5rem;
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.6);
    background: rgba(255 255 255 / 0.08);
    backdrop-filter: blur(12px);
    text-align: center;
  }
  h1 {
    margin-bottom: 1.5rem;
  }
  .link-list {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }
  .link-list a {
    padding: 1rem 1.5rem;
    background: rgba(255 255 255 / 0.12);
    border-radius: 2rem;
    text-decoration: none;
    color: inherit;
    font-weight: 500;
    transition: background 0.3s ease, transform 0.3s ease;
  }
  .link-list a:hover {
    background: rgba(255 255 255 / 0.3);
    transform: translateY(-3px);
    box-shadow: 0 0 12px rgba(255 255 255 / 0.4);
  }
</style>
</head>
<body>

<canvas id="lavaCanvas"></canvas>

<div class="container">
  <div class="card">
    <h1>Mes Liens</h1>
    <div class="link-list">
      <a href="#">Lien 1</a>
      <a href="#">Lien 2</a>
      <a href="#">Lien 3</a>
    </div>
  </div>
</div>

<script>
  const canvas = document.getElementById('lavaCanvas');
  const ctx = canvas.getContext('2d');
  let width, height;

  function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    const dpr = window.devicePixelRatio || 1;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr);
  }
  window.addEventListener('resize', resize);
  resize();

  // Blob setup
  const pointsCount = 40;
  const baseWidth = width * 0.8;
  const baseHeight = height * 0.35;
  const blobBaseY = height * 0.65; // fixe en bas
  const centerX = width / 2;

  // Points horizontaux
  const points = [];
  for(let i = 0; i <= pointsCount; i++) {
    points.push({
      x: (i / pointsCount) * baseWidth + (width - baseWidth) / 2,
      baseY: 0,
      offsetPhase: Math.random() * Math.PI * 2
    });
  }

  // Bulles / petits bouts qui montent
  const bubbleCount = 12;
  const bubbles = [];
  for(let i=0; i < bubbleCount; i++) {
    bubbles.push({
      baseIndex: Math.floor(Math.random() * pointsCount), // point d'origine sur blob
      progress: Math.random(), // position verticale entre 0 (base blob) et 1 (haut écran)
      speed: 0.002 + Math.random() * 0.003,
      size: 10 + Math.random() * 10,
      offsetPhase: Math.random() * Math.PI * 2
    });
  }

  function drawBlob(t) {
    ctx.clearRect(0, 0, width, height);

    // Ondulations sinus
    const amplitude = 30;
    const wavelength = baseWidth / 4;
    points.forEach((pt, i) => {
      pt.baseY = amplitude * Math.sin((t * 0.005) + pt.offsetPhase + i * 0.3);
    });

    // Dessiner blob
    ctx.beginPath();

    // Premier point
    const startX = points[0].x;
    const startY = blobBaseY + points[0].baseY;
    ctx.moveTo(startX, startY);

    // Béziers entre points
    for(let i=1; i<points.length; i++) {
      const prev = points[i-1];
      const curr = points[i];
      // Contrôle au milieu
      const cx = (prev.x + curr.x) / 2;
      const cy = blobBaseY + ((prev.baseY + curr.baseY) / 2);
      ctx.quadraticCurveTo(prev.x, blobBaseY + prev.baseY, cx, cy);
    }

    // Fermeture du bas (ligne droite sous le blob)
    const lastPt = points[points.length - 1];
    ctx.lineTo(lastPt.x, height + 100);
    ctx.lineTo(startX, height + 100);
    ctx.closePath();

    // Dégradé rouge/orangé
    const gradient = ctx.createLinearGradient(0, blobBaseY - baseHeight, 0, height + 100);
    gradient.addColorStop(0, 'rgba(255,120,20,0.85)');
    gradient.addColorStop(0.5, 'rgba(255,70,0,0.9)');
    gradient.addColorStop(1, 'rgba(120,20,0,0.9)');

    ctx.fillStyle = gradient;
    ctx.shadowColor = 'rgba(255,100,30,0.8)';
    ctx.shadowBlur = 25;
    ctx.fill();
    ctx.shadowBlur = 0;

    // Dessiner les bulles / petits bouts qui montent
    bubbles.forEach(bubble => {
      bubble.progress += bubble.speed;
      if(bubble.progress > 1) {
        bubble.progress = 0;
        bubble.baseIndex = Math.floor(Math.random() * pointsCount);
        bubble.size = 10 + Math.random() * 10;
        bubble.speed = 0.002 + Math.random() * 0.003;
      }

      // Position X du point de base + légère oscillation horizontale
      const basePt = points[bubble.baseIndex];
      const oscillX = 10 * Math.sin(t * 0.01 + bubble.offsetPhase);
      const x = basePt.x + oscillX;

      // Position Y monte du blobBaseY vers le haut de l'écran (progress = 0 => base blob, 1 => haut)
      // On ajoute un petit mouvement sinusoïdal pour simuler fluide
      const y = blobBaseY + basePt.baseY - bubble.progress * (blobBaseY + 100) + 10 * Math.sin(t * 0.02 + bubble.offsetPhase);

      // Taille oscillante
      const size = bubble.size * (0.5 + 0.5 * Math.sin(t * 0.05 + bubble.offsetPhase));

      ctx.beginPath();
      ctx.ellipse(x, y, size * 0.7, size, 0, 0, 2 * Math.PI);
      ctx.fillStyle = 'rgba(255,160,50,0.7)';
      ctx.shadowColor = 'rgba(255,140,30,0.8)';
      ctx.shadowBlur = 10;
      ctx.fill();
      ctx.shadowBlur = 0;
    });
  }

  function animate(t=0) {
    drawBlob(t);
    requestAnimationFrame(animate);
  }

  animate();
</script>

</body>
</html>
